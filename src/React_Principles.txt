
/**
1) What is React?
* JS Library - Open Source (Created and Mantained by Facebook)
SSR - Server Side Render  - Classic By request (Dinamic Content)
CSR - Client Side Render (SPA) - Page Lever (#app) and Component Level (#someId)
SSG - Static Site Generation - Classic By Request with all together JS, CSS, HTML, ... (Performance and BLOG)
ISR - Incremental Static Generation - SSG + Incremental

2) Main Features:
* JSX - Javascript Syntax Extension Language (React Elements that Extends HTML Elements)
* Virtual D.O.M (Document Object Model)
* State ==> If updated will rerender the component
* Props ==> Parent to Child, if Changes will rerender component
* One Way Data Bind - Unidirection (Parent to Child)
* Key Usage (Performance Virtual DOM Manipulation) in a Iteration = Render()
* Component Based:
  - MVC:
  ** Model (data)
  ** View (Render())
  ** Controller (Controll ==> Logic between Data and Render())

3) Virtual D.O.M (Document Object Model):
*  Copy of Real DOM.
* 2 Virtual DOMs (Prev State and Current State).
* Reconsiliation Event (Diffing Algorithm).
* Minimal Changes on the Real DOM (Tree or Element Attributes).

4) Class Components:
* Js Class extends React.Component
* Construnction
  - Receve Props as arg
  - Super (Props) // Super() ==> Call Constructor in Parent Class + Props (React)
  - Initial State Object
* Basic LifeCycle Methods:
  - constructor()
  - componentDidUpdate (PrevProps, PrevState, Snapshots)
  - render()
  - componenentDidMount() => Ref's + Fetch Data + Early State Updates
  - componentWillUnmount (Clear Listeners + subscriptions)
  - ** shouldComponentUpdate() => Avoid unecessary rendering - Performance Optimization
  - *** componentDidCatch() ==> Error Boundaries Class Component UI

5) Functional Components (Better Readability, Less code, Better State Management, reusable code (Custom hooks))
* Presentation Comp or Stateless
* Statefull Comp (React Hooks)
* Arrow (Instantiation) or Function (Declarative) Functions
* return JSX
* props as args + children hidden
* Don't need this declaration all the time.

6) React Hooks (Functional Components):
* Basic Rules ==> Top Level, not in iterations, not in conditions
* Builded In function from React Library

6.1) useState:
* State management.
* Arguments are the initial state.
* Returns a tuple => State + function to Change update this state.
* SetState function: returns the current State, can be called as CB func passing the PrevState.

6.2) useEffect: 
* Component LifeCycles
* Pass a CB Function as argument and dependencies (Run if updates Dependecies)
* Dependencies: 
  - No Depenedencies - Run Every time (Similar to componentDidUpdate)
  - Empty Dependecies [] - Run on Mount (Similar to componenentDidMount)
  - Receives State, Props, Variables and Functions as dependencies 
* Returning Function:
  - Clear Up Functions (Listeners, On Going Fetchs, and cancel subscriptions)
  - Similar to componentWillUnmount
*** Avoiding Infinite Loop:
  - useCallback to memoize Functions (new functions in each rendering)
  - useMemo to memoize objects (New referenced objects)
  - useRef.current to memoize arrays (new referenced array)

6.3) useContext:
* Context API usage:
  1 - Create the Context ==> const AuthContext = React.createContext( InitialValue );
  2 - Wrapp Component with a <AuthContext.Provider value={ /* Value(s) = State, SetState */}/>
  3 - On nested component call const [state, setSatte] = useContext(AuthContext);

6.4) UseRef:
* Memoize arrays;
* DOM Refence to future manipulation (No State manipulation)
* Update values without trigger re-rendering
*** Don't forget *.current

6.5) useCallback:
* Memoize Functions
* Avoid Expencive computations on Rerendeting (Functions)
* Dependecies - Will rerun if dependencies changes

6.6) useMemo:
* Memoize Objects:
* Avoid Expencive computations on Rerendeting
* Dependecies - Will rerun if dependencies changes

6.7) useReducer:
* Used for complex Logic on State Management - 3 Variations at least
* Call ==> const [state, dispatch] = useReduce(reducerFunc, InitialState);
* ReducerFunc ==> function reducerName(state, action) { siwtch (action.type) { case actionName: return doSomething to state, ... }}
* Dipatching Changes ==> onClick={() => dispatch({type: actionName})}

6.8) useID = Created uniqueId;

6.7) Custom Hools:
* 'use' prefix for initialization 
* must return something (Data, State management, Multiple Things, Reusable Code, Abstractions);

7) Suspense - Lazy Loading
* Wrapp into <React.Suspense fallback={<Component/>}/>
* Import Component ==> const OtherComp = React.lazy(() => import("someplace"))


*/