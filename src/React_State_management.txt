/*

1) Native State Management: (By Default)
  * useState (Build-in React Hook):
    ** Returns a duple (Array of two items) ==>  'currentState' + 'setFunction' to modify the currentState
    ** Will receive initial state or function to start the state
    *** Within the Component (Scoped on the component)

  * useReducer (Build-in React Hook):
    ** Returns a duple (Array of two items) ==> 'currentState' + 'dispatch' will invoke the change by a action and a value/payload
    ** useReducer(reducerFunc, initialState)
    ** Will receive initial state as a function called reducer:
      *** This reducer function will receive the state and an action as args:
         e.g.: function reducerFunc(state, action) { 
          switch(action.type) {
            case actionTypeName: 
            ...logic to modify the state based on the payload
              return { ...newState };
            default:
              Throw new Error("")
          }
        }
    *** reducerFunction = ((state, action) => ({...state, ...action}))

  * useCallback: (Calculation - Not the same as React.memo - Not memoize)
    ** Memoize Functions
    ** Avoid Expensive computations on Re-rendering (Functions)
    ** Dependencies - Will rerun if dependencies changes

  * useMemo: (Calculation - Not the same as React.memo - Not memoize)
    ** Memoize Objects or Arrays:
    ** Avoid Expensive computations on Re-rendering
    ** Dependencies - Will rerun if dependencies changes

  * useRef: (Will not re-render the component if updated)
    ** Uncontrolled Input
    ** Update a value to not render the complex
    *** use 'current'




2) Indirect State Management: (Third Party Libraries - Somehow manage states)
3) Direct State Management: (Third Party Libraries - Soul function is to Manage State)
4) New Features

8 - RTK React Query and SWR (Promise Watchers)
6 - Redux & Redux-Toolkit (Vs)
9 - Zustand: (Uni-directional State Management like Redux)
  * Docs: https://www.npmjs.com/package/zustand
10 - Valtio (Bi-direction State Management like MobX)
11 - Jotai (Atomic State Management or Nano)


=====================





1 - Redux (store, state tree, action, dispatch, reducer):

- Store: 
* is a reference to a only State tree Object 
* API is {subscribe, dispatch, getState}
```
function reducerName(state = {...}, action) {
  switch(action.type){
    case 'whatever':
      return { ... } // Altered state; 
      ...
    default:
      return state;
  }
}
let store = createStore(reducerName);
store.subscribe(() => store.getState);
store.dispatch({type: whatever}) type is the action type;
```

- State tree = State:
* is the object on the Store that will be updated
* contains only pain JS objects, arrays and primitives;

- Reducer: 
* is a function to updated the State Tree 
* ```function reducerName(State, action) => { return new State }```;
* Think as event listener with handle actions type.

- Action: 
* is a object to manage the reduce changes returning a new State Tree Changed;
* usually text with domain and eventName, like `domain/eventName`
```
const addTodo = text => {
  return {
    type: 'todos/todoAdded',
    payload: text
  }
}
```



2 - Redux - React Tool Kit 

